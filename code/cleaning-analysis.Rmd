---
title: 'Práctica 2: Limpieza y análisis de datos'
author: "Renán Freire, Manuel García"
date: "20/05/2021"
output:
  pdf_document: 
    toc: yes
    toc_depth: '2'
  html_document: 
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---
```{r echo=FALSE, results=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(VIM)
```

# Descripción del dataset

## Descripción

Siguiendo la línea del deporte e inspirados en la película “Moneyball”, se ha encontrado un dataset llamado “Baseball Databank” (https://www.kaggle.com/open-source-sports/baseball-databank), que contiene una extensa base de datos sobre béisbol recopilada por el periodista Sean Lahman divididos en archivos planos (csv) y entre los más importantes se tiene:

* Master.csv: Contiene datos biográficos de los jugadores, como por ejemplo: Nombres, apellidos, lugar de nacimiento, año de nacimiento. Cada jugador tiene un identificado “playerID”.
  
* Batting.csv: Este archivo contiene datos estadísticos de bateo (corridas, homerun, número de golpes, etc).
  
* Pitching: Este archivo contiene datos estadísticos de lanzamiento (jugos ganados, perdidos, etc).
  
* Fielding.csv - Este archivo contiene datos estadísticos de las diferentes habilidades para moverse en el campo y atrapar, parar, lanzar, etc.

* Salaries.csv. Este archivo contiene el salario de cada jugador de acuerdo al año, equipo y liga jugada.
      
Cada registro de los datasets explicados están vinculado a un jugador mediante su identificador “playerID” además de otros identificadores relacionados a otros catálogos.

## Importancia y Objetivo 

Para esta práctica se ha centrado en el béisbol, debido a su importancia en el ámbito del BigData, ya que año tras año, este deporte genera gran cantidad de datos estadísticos en base a su complejidad, debido a sus diferentes reglas de juego y las diferentes características que cada jugador debe desempeñar de acuerdo a su posición en el campo de juego. 

El objetivo para el cual usaremos los datos, está orientado a la predicción de los salarios de los bateadores y su dependencia con los datos de desempeño de cada jugador,  generando modelos a través de algoritmos aprendizaje supervisado. Entre las preguntas a resolver tenemos:

* Los números de homeruns, strikeout y golpes , tienen una correlación con el valor del salario?

* La edad de cada bateador además de los datos de desempeño (homeruns, strikeout y golpes) tienen una correlación con el valor del salario?
  
* Evaluar si los bateadores de Estados Unidos ganan más que los bateadores del resto del mundo.

# Integración y selección de los datos de interés a analizar.

## Integración de fuentes de datos

De acuerdo al análisis del conjunto de datos y a la problemática a resolver, planteada para esta práctica, vamos a trabajar con los datos biográficos de los jugadores que juegan en la posición de bateadores además de sus datos estadísticos y su salario. Para esto vamos a realizar una fusión horizontal y vertical de los archivos: master.csv, batting.csv, salaries.csv; mediante los identificadores: “playerID” que relaciona cada fuente con el jugador y "yearID" vincula los años de los diferentes datos de rendimiento y el salario correspondiente.

```{r}
# Lectura de fuente de datos necesitadas
dataPlayer <- read.csv('../dataset/Master.csv')
print("[*] Dimensiones")
dim(dataPlayer)
print("[*] Nombre Columnas")
colnames(dataPlayer)
```

La fuente de datos **Master.csv** tiene las siguientes dimensiones: 18846 registros y 24 columnas.



```{r}
# Lectura de fuente de datos necesitadas
dataBatting <- read.csv('../dataset/Batting.csv')
print("[*] Dimensiones")
dim(dataBatting)
print("[*] Nombre Columnas")
colnames(dataBatting)
```

La fuente de datos **Batting.csv** tiene las siguientes dimensiones: 101332 registros y 22 columnas.

```{r}
# Lectura de fuente de datos necesitadas
dataSalaries <- read.csv('../dataset/Salaries.csv')
print("[*] Dimensiones")
dim(dataSalaries)
print("[*] Nombre Columnas")
colnames(dataSalaries)
```

La fuente de datos **Salaries.csv** tiene las siguientes dimensiones: 25575 registros y 5 columnas.

```{r}
# Integración fuentes
mergeCols <- c("playerID", "yearID")

datasetBateadores <- merge(dataPlayer,dataSalaries,by="playerID")
datasetBateadores <- merge(dataBatting,datasetBateadores,by=mergeCols)
print("[*] Dimensiones")
dim(datasetBateadores)
print("[*] Nombre Columnas")
colnames(datasetBateadores)
```

El dataset final tiene las siguientes dimensiones: 27385 registros y 48 columnas.

```{r}
head(datasetBateadores)
```


## Selección de datos y reducción de dimensionalidad 

Una vez analizado el dataset final, se puede identificar datos perdidos (N.D) para los años iniciales, por lo tanto, para nuestro objetivo, vamos a seleccionar todos los jugadores de posición bateadores correspondiente a los años 2014, 2015, siendo estos los datos más actuales disponibles y como resultado tenemos un conjunto de datos de alta calidad sin valores perdidos. 

```{r}
# Selección de instancias de acuerdo a los anios 2014,2015
datasetBateadores <- filter(datasetBateadores, yearID>2013 & yearID<2016)
head(datasetBateadores)
```

Como se observa en la sección anterior, el dataset contiene una gran cantidad de atributos, por lo tanto aplicamos la técnica de selección de subconjuntos de atributos para seleccionar datos de interés. Primeramente los atributos correspondientes a los datos biográficos de cada jugar, seleccionaremos manualmente, identificando cuales son más relevantes para nuestro estudio *(yearID, playerID, nameFirst, nameLast, birthCountry, bats, birthYear, debut)*, ademas eliminaremos atributos de códigos *(stint, teamID.x, lgID.x)* que no tiene significado en nuestro análisis. Como resultado de esta selección tendremos el siguiente dataset:


```{r}
# Selección de atributos de interés de datos biográficos del jugador
datasetBateadores <-select(datasetBateadores, 'yearID','playerID','nameFirst', 'nameLast', 
                           'birthCountry','bats','birthYear','debut','G', 'AB', 'R', 'H', 
                           'X2B', 'X3B', 'HR', 'RBI', 'SB', 'CS', 'BB', 'SO', 'IBB', 'HBP', 
                           'SH', 'SF', 'GIDP','salary');
head(datasetBateadores)
```


Los campos **birthYear** y **debut** son transformados a la edad del jugador de acuerdo al año de la observación y al número de años de experiencia del jugador respectivamente. Todo este proceso se presenta a continuación:

```{r}
# Transformar fecha debut en anios de experiencia
datasetBateadores$Exp<-datasetBateadores$yearID - as.numeric(format(as.Date(datasetBateadores$debut, format="%Y-%m-%d"),"%Y"))
# Transformar anio de nacimiento por edad
datasetBateadores$Edad<-datasetBateadores$yearID - datasetBateadores$birthYear
# Eliminamos columnas 'birthYear','debut'
datasetBateadores <- datasetBateadores[ -c(7:8) ]

head(datasetBateadores)
```

Con respecto a la selección de los atributos numéricos que representan a los datos estadísticos de rendimiento de un jugador, calcularemos los diferentes coeficientes de correlación entre parejas de variables, identificando cual de ellas están asociadas. Si existen parejas de variables con coeficientes de correlación superior al 80% descartamos una de las dos variables. A continuación se presenta la matriz de correlación y en base a dicha matriz la selección de atributos.

```{r fig.align='center', message=FALSE, warning=FALSE, fig.width=14, fig.height=14}
library(psych)

corPlot(datasetBateadores[,7:26], cex = 0.7, main = "Matriz de correlación")

```

En base a la matriz de correlación han identificado los siguientes atributos correlacionados fuertemente en base al coeficiente superior a 80% y que serán eliminados: AB, R, H, X2B, RBI, BB, SO, Edad. 

```{r}
# Selección de atributos de interés de datos de rendimiento 
datasetBateadores <-select(datasetBateadores, 'yearID','playerID','nameFirst', 'nameLast', 
                           'birthCountry','bats','Exp','G', 'X3B', 'HR', 'SB', 'CS', 'IBB', 
                           'HBP', 'SH', 'SF', 'GIDP','salary');
head(datasetBateadores, n =10)
```

A continuación, se va a detallar cada uno de los atributos que contiene el dataset final.

* yearID: Año de recopilación de datos de desempeño y salario. 

* playerID: Identificador del jugador.

* nameFirst: Nombre del jugador.

* nameLast: Apellido del jugador.

* birthCountry: País de nacimiento del jugador.

* bats: Indica si el jugador es diestro o zurdo para coger el bat.

* exp: Anõs de experiencia desde su debut.

* G: Número de juegos a lo largo de la carrera.

* X3B: Número de veces que avanzó a tercera base el jugador.

* HR: Número de homerun.

* SB: Número de bases robadas por el jugador.

* CS: Número de eliminaciones por robar una base.

* IBB: Número de bases por bolas intencionales.

* HBP: Número de veces que fue golpeado por los lanzamientos de pitcher.

* SH: Números de sacrificios.

* SF: Número de elevados de sacrificio.

* GIDP: Núemero de Bateos para dobleplay.

* Salary: Salario anual del jugador.


Una vez realizado la selección de datos y la reducción de dimensionalidad, se ha descubierto que para ciertos jugadores del datastet tienen más de un registro para el mismo año, de acuerdo a  la documentación de Sea Lahman, estos datos se presentan de esa forma ya que corresponden a los datos estadísticos de un jugador que estuvo en diferentes equipos o ligas para el mismo año. Para solucionar esto, se va a fusionar los registros de ese jugador en una sola fila y los datos estadísticos de rendimiento tendrán la suma de sus valores y para los años de experiencia y salario, como sus valores son iguales en los dos registros, solamente se escoge uno de ellos.

```{r}
# Se agrupan registros para el mismo jugador calculando la media de los datos estadisticos
datasetBateadores <- aggregate(cbind(G, X3B, HR, SB, CS, IBB, HBP, SH, SF, GIDP) ~ yearID 
                               + playerID + nameFirst +  nameLast +  birthCountry + bats 
                               + Exp + salary, data = datasetBateadores, FUN = sum)
# Ordenar por idJugador
datasetBateadores <- datasetBateadores[order(datasetBateadores$playerID),]
head(datasetBateadores, n=10)
```

## Tipos de variables

Después de haber seleccionado las observaciones y los atributos para el conjunto de datos a trabajar, se verificará los tipos de datos de las diferentes columnas que conforman en el dataset, mediante la función de R **str()**, como se ve a continuación:

```{r}
str(datasetBateadores)
```

De acuerdo a la salida de esta función, tenemos que los datos de rendimimento que se van a analizar son de tipo entero, listos para los análisis posteriores. Solo la variable Exp será trasformada de numérica a entera.

```{r}
datasetBateadores$Exp <- as.integer(datasetBateadores$Exp)
head(datasetBateadores, n=10)
```

# Limpieza de datos

## Detección y tratamiento de valores perdidos

EL dataset final, no contiene datos perdidos o no definidos ya que en secciones anteriores se filtraron los datos para los años mas actuales debido a que los años más antiguos tenían un gran porcentaje de datos no definidos.

```{r}
# Valores perdidos determinados por N.A
colSums(is.na(datasetBateadores))
```

Sin embargo, después de realizar una inspección al conjunto de datos, se ha identificado un caso especial, donde existen registros con valor 0 en las variables de rendimiento **X3B, HR, SB, CS, IBB, HBP, SH, SF, GIDP** y la variable salario posse un valor. Este caso es un problema, debido a que una de nuestras preguntas iniciales consisten en determinar la relación del las variables de rendimiento con el valor del salario del jugador. Para solucionar esto, se va a implementar un proceso de imputación para estos valores 0 de todas las variables antes mencionadas mediante el algoritmo del vecino más cercano KNN.

El proceso consiste en los siguientes pasos:

* Asignar el valor *NA* a las variables de rendimiento con valor 0 cuyos registros cumplan la condición:  X3B == 0 & HR == 0 & SB == 0 & CS == 0 & IBB == 0 & HBP == 0 & SH == 0 & SF == 0 & GIDP == 0.

* Imputación de valores *NA* haciendo uso del modelo KNN, rellenando los valores *NA*, en base a las demás observaciones del dataset, promediando todos los puntos más cercanos. 

Esta implementación se puede observar a continuación, que consta de la identificación del número de casos con datos de rendimiento en 0, además se inspeccionan las variables salario y G para ver si poseen valores en 0 y finalmente la inputación de valores de acuerdo a lo panteado.



```{r}
# Verificamos datos de salario en 0
dfSalarioCero <- filter(datasetBateadores, salary==0)

# Verificamos datos de G en 0
dfGCero <- filter(datasetBateadores, G==0)


# Verificamos datos de rendimiento en 0
dfEstadisticasCero <- filter(datasetBateadores, X3B == 0 & HR == 0 & SB == 0 & CS == 0 & IBB == 0 & HBP == 0 & SH == 0 & SF == 0 & GIDP == 0 )

# cosntruye dataframe de resultados
resultados <-data.frame(c(nrow(dfEstadisticasCero), nrow(dfSalarioCero), nrow(dfGCero)), 
                        c('DATOS RENDIMIENTO EN 0', 'DATOS SALARIOS EN 0', 'DATOS G EN 0'))
resultados <- setNames(resultados, c('Nro. Registros', 'Descripción'))
resultados
```


```{r}
# Obtener indices de los datos de rendimiento tengan todos 0
indicesFiltros <- which(datasetBateadores$X3B == 0 & datasetBateadores$HR == 0 & 
                          datasetBateadores$SB == 0 & datasetBateadores$CS == 0 & 
                          datasetBateadores$IBB == 0 & datasetBateadores$HBP == 0 & 
                          datasetBateadores$SH == 0 & datasetBateadores$SF == 0 & 
                          datasetBateadores$GIDP == 0)
# Reemplazar valores de 0 por NA para los indices extraídos
datasetBateadores$X3B[indicesFiltros] <- NA
datasetBateadores$HR[indicesFiltros] <- NA
datasetBateadores$SB[indicesFiltros] <- NA
datasetBateadores$CS[indicesFiltros] <- NA
datasetBateadores$IBB[indicesFiltros] <- NA
datasetBateadores$HBP[indicesFiltros] <- NA
datasetBateadores$SH[indicesFiltros] <- NA
datasetBateadores$SF[indicesFiltros] <- NA
datasetBateadores$GIDP[indicesFiltros] <- NA
# Verificamos valores NA
colSums(is.na(datasetBateadores))
```

```{r}
# Imputación de valores perdidos
datasetBateadores <- kNN(datasetBateadores)
head(datasetBateadores,n=10)
```

La función utilizada para imputar valores adiciona al dataset unas nuevas columnas de tipo booleanas indicando true o false para el proceso KNN. Por lo tanto, eliminaremos estas columnas de nuestra dataset final.

```{r}
# Eliminar columnas agregagdas por el método KNN usado para imputación
datasetBateadores <- datasetBateadores[ -c(19:36) ]
head(datasetBateadores, n=10)
```


## Identificación y tratamiento de valores extremos.

Para nuestro dataset final vamos a identificar si existen valores extremos sobre las variables de tipo numérico, mediante gráficas de caja y bigote para cada variable implicada. A continuación se presentan las gŕaficas y los resultados obtenidos.

```{r fig.width=10, fig.height=15}
par(mfrow=c(6,2))
boxplot(datasetBateadores$G, main="BoxPlot G", col="green")
outliersG <- boxplot.stats(datasetBateadores$G)$out

boxplot(datasetBateadores$X3B, main="BoxPlot X3B", col="blue")
outliersX3B <- boxplot.stats(datasetBateadores$X3B)$out

boxplot(datasetBateadores$HR, main="BoxPlot HR", col="red")
outliersHR <- boxplot.stats(datasetBateadores$HR)$out

boxplot(datasetBateadores$SB, main="BoxPlot SB", col="brown")
outliersSB <- boxplot.stats(datasetBateadores$SB)$out

boxplot(datasetBateadores$CS, main="BoxPlot CS", col="yellow")
outliersCS <- boxplot.stats(datasetBateadores$CS)$out

boxplot(datasetBateadores$IBB, main="BoxPlot IBB", col="gray")
outliersIBB <- boxplot.stats(datasetBateadores$IBB)$out

boxplot(datasetBateadores$HBP, main="BoxPlot HBP", col="black")
outliersHBP <- boxplot.stats(datasetBateadores$HBP)$out

boxplot(datasetBateadores$SH, main="BoxPlot SH", col="green3")
outliersSH <- boxplot.stats(datasetBateadores$SH)$out

boxplot(datasetBateadores$SF, main="BoxPlot SF", col="cyan")
outliersSF <- boxplot.stats(datasetBateadores$SF)$out

boxplot(datasetBateadores$GIDP, main="BoxPlot GIDP", col="magenta")
outliersGIDP <- boxplot.stats(datasetBateadores$GIDP)$out

boxplot(datasetBateadores$Exp, main="BoxPlot Exp", col="pink")
outliersExp <- boxplot.stats(datasetBateadores$Exp)$out

boxplot(datasetBateadores$salary, main="BoxPlot salary", col="orange")
outlierssalary <- boxplot.stats(datasetBateadores$salary)$out

```

De acuerdo a los gráficos, podemos identificar el número de valores atípicos para cada atributo.

```{r}
resultadosOutliersDF <-data.frame(c(length(outliersG),
                                    length(outliersX3B),
                                    length(outliersHR),
                                    length(outliersSB),
                                    length(outliersCS),
                                    length(outliersIBB),
                                    length(outliersHBP),
                                    length(outliersSH),
                                    length(outliersSF),
                                    length(outliersGIDP),
                                    length(outliersExp),
                                    length(outlierssalary)
                                    ),
                        c('VARIABLE G',
                          'VARIABLE X3B',
                          'VARIABLE HR',
                          'VARIABLE SB',
                          'VARIABLE CS',
                          'VARIABLE IBB',
                          'VARIABLE HBP',
                          'VARIABLE SH',
                          'VARIABLE SF',
                          'VARIABLE GIDP',
                          'VARIABLE Exp',
                          'VARIABLE salary'
                          )
                        )
resultadosOutliersDF <- setNames(resultadosOutliersDF, c('Nro. Valores Atípicos', 'Variable'))
resultadosOutliersDF
```

El tratamiento que hemos decidido realizar sobre los valores atípicos es la eliminación de las observaciones que contengan esos valores. Se ha tomado esta decisión para evitar sesgos dentro de nuestro análisis, ya que este se basa directamente sobres estas variables. El proceso es implementado a continuación.

```{r}
# reemplazo de outliers con NA  y posterior eliminación
outliersReplace <- function(vectorOutliers, data){
  for (val in vectorOutliers)
  {
    data[data==val] <- NA
  }
  data
}
 
datasetBateadores$X3B <- outliersReplace(outliersX3B, datasetBateadores$X3B)
datasetBateadores$HR <- outliersReplace(outliersHR, datasetBateadores$HR)
datasetBateadores$SB <- outliersReplace(outliersSB, datasetBateadores$SB)
datasetBateadores$CS <- outliersReplace(outliersCS, datasetBateadores$CS)
datasetBateadores$IBB <- outliersReplace(outliersIBB, datasetBateadores$IBB)
datasetBateadores$HBP <- outliersReplace(outliersHBP, datasetBateadores$HBP)
datasetBateadores$SH <- outliersReplace(outliersSH, datasetBateadores$SH)
datasetBateadores$SF <- outliersReplace(outliersSF, datasetBateadores$SF)
datasetBateadores$GIDP <- outliersReplace(outliersGIDP, datasetBateadores$GIDP)
datasetBateadores$Exp <- outliersReplace(outliersExp, datasetBateadores$Exp)
datasetBateadores$salary <- outliersReplace(outlierssalary, datasetBateadores$salary)

datasetBateadores <- na.omit(datasetBateadores) 


```


Con esto hemos concluido con la fase de pre-procesamiento de los datos. A continuación se examina la dimensión total del dataset final.
```{r}
# Dimension final del dataset
dim(datasetBateadores)
```


# Análisis de los datos.

## Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar).

## Comprobación de la normalidad y homogeneidad de la varianza.

## Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.

# Representación de los resultados a partir de tablas y gráficas.

# Resolución del problema. A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?

